using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

using Newtonsoft.Json;

using api = SteamControllerApi;
using Robot;


namespace Input {
	using T = System.Int32;

	public abstract class Hardware {
		[JsonIgnore]
		protected static api.IInputData[] currentEvents = EventDoer.CurrentEvents;
		[JsonIgnore]
		protected static IRobot robot = new WindowsRobot(createVirtualGamepad: false);

		static public void EnableGamepad() => robot = new WindowsRobot(createVirtualGamepad: true);

		static public void DisableGamepad() => robot = new WindowsRobot(createVirtualGamepad: false);

		///<summary>Takes an input event generated by the steam controller and 
		///generates input by way of the state of the hardware object.</summary>
		public abstract void DoEvent(api.IInputData input);

		///<summary>Defines what to do when the hardware object is no longer needed and
		/// needs to clean up.</summary>
		public abstract void ReleaseAll();

		///<summary>Defines what to do when an object whose containing layer on the action layer list was revealed
		/// after being hidden.</summary>
		public abstract void Unfreeze(api.IInputData newInput);

		/// <summary>r is the range of a signed short, angle is between -PI and PI.</summary>
		protected (double r, double theta) CartesianToPolar(int x, int y) {
			double r = Math.Sqrt(x * x + y * y);
			double theta = Double.NaN;
			if (y >= 0 && r != 0) theta = Math.Acos(x / r);
			else if (y < 0)       theta = -Math.Acos(x / r);
			else if (r == 0)      theta = Double.NaN;
			return (r, theta);
		}

		protected (double r, double cos, double sin) CartesianToAngle(int x, int y) {
			double r = Math.Sqrt(x * x + y * y);
			return (r, x / r, y / r);
		}
	}

	// Implemented as a composited class because C# support for mixins is wonky.
	public enum Curve { None, Linear, Wide, Custom }

	public struct Accelerator {
		/// <summary>Multiple of the existing sensitivity.</summary>
		public double Amount { get; set; }
		public int LowerBoundary { get => lowerBoundary; set => lowerBoundary = value < 0 ? 0 : value; }
		public int UpperBoundary { get => upperBoundary; set => upperBoundary = value < 0 ? Int32.MaxValue : value; }
		public Curve Kind { get; set; }

		private int lowerBoundary, upperBoundary;

		public Accelerator(
			double amount = 2,
			int lowerBoundary = 0,
			int upperBoundary = int.MaxValue,
			Curve kind = Curve.Wide
		) {
			this.Amount = amount;
			this.lowerBoundary = lowerBoundary;
			this.upperBoundary = upperBoundary;
			this.Kind = kind;
		}

		public (double x, double y) AccelerateInput(double x, double y, double existingSensitivity) {
			var magnitude = Math.Sqrt(x * x + y * y);
			var range = Kind switch {
				Curve.None   => 0,
				Curve.Linear => (magnitude - lowerBoundary) / (upperBoundary - lowerBoundary),
				Curve.Wide   => Math.Pow((magnitude - lowerBoundary) / (upperBoundary - lowerBoundary), 3),
				                /* Exponent should always be negative values outside range are clamped to 0. */
				_ => throw new NotSupportedException(Kind.ToString())
			};
			var weight = Math.Clamp(range, 0, 1);
			var sensitivity = (1 - weight) * existingSensitivity + weight * existingSensitivity * Amount;

			return (x * sensitivity, y * sensitivity);
		}

		public (double x, double y) AccelerateInput((double x, double y) c, double existingSensitivity) =>
			AccelerateInput(c.x, c.y, existingSensitivity);
	}

	// Mixin is actually a composited class and not a true mixin because C#
	// support for mixins is wonky.
	// Currently broken, will halt program.

	// Taken from http://gyrowiki.jibbsmart.com/blog:good-gyro-controls-part-1:the-gyro-is-a-mouse

	public struct PointSmoother {
		public int Smoothing;

		private (T x, T y)[] buffer;
		private int bufferIndex;

		public PointSmoother(int smoothing, int bufferSize = 16) {
			this.Smoothing = smoothing;
			this.buffer = new (T x, T y)[bufferSize];
			this.bufferIndex = 0;
		}

		public (T x, T y) SmoothInput((T x, T y) vector) {
			buffer[bufferIndex] = vector;

			(T x, T y) average = (0, 0);
			foreach (var v in buffer) {
				average.x += v.x;
				average.y += v.y;
			}

			bufferIndex = (bufferIndex + 1) % buffer.Length;
			return ((T, T))(average.x / buffer.Length, average.y / buffer.Length);
		}

		public void ClearSmoothingBuffer(T x = 0, T y = 0) {
			var bufferSize = buffer.Length;
			for (int i = 0; i < buffer.Length; i++) { buffer[i].x = x; buffer[i].y = y; }
		}

		///<summary>Clears buffer.  Defaults to (x: 0, y: 0).</summary>
		public void ClearSmoothingBuffer((T x, T y) toClearTo) => this.ClearSmoothingBuffer(toClearTo.x, toClearTo.y);

		public (T x, T y) SoftTieredSmooth((T x, T y) vector) {
			var lowerThreshold = Smoothing / 2d;
			var upperThreshold = (double)Smoothing;
			var magnitude = Math.Sqrt(vector.x * vector.x + vector.y * vector.y);

			// If magnitude is lower that threshold result is < 0 and so clamped value is zero.
			var directWeight = Math.Clamp(
				value: (magnitude - lowerThreshold) / (upperThreshold - lowerThreshold),
				min:   0,
				max:   1);

			(double x, double y) smoothed = this.SmoothInput(vector);
			smoothed.x *= 1d - directWeight;
			smoothed.y *= 1d - directWeight;
			var weightedVector = (x: vector.x * directWeight, y: vector.y * directWeight);

			return ((T, T))(weightedVector.x + smoothed.x, weightedVector.y + smoothed.y);
		}
	}
}